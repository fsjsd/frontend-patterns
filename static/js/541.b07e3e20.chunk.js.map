{"version":3,"file":"static/js/541.b07e3e20.chunk.js","mappings":"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","sources":["features/snakegame/utils.ts","features/snakegame/BoardAscii.tsx","features/snakegame/BoardCanvas.tsx","features/snakegame/BoardHtml.tsx","features/snakegame/reducer.ts","features/snakegame/SnakeGame.tsx"],"sourcesContent":["import { Coord, SnakeGameShape } from \"./types\";\r\n\r\nexport const BOARD_COLS = 21;\r\nexport const BOARD_ROWS = 21;\r\n\r\nexport const INITIAL_SNAKE_SPEED = 200;\r\n\r\nexport const INITIAL_SNAKE_COORDS: Coord[] = [\r\n  { x: 10, y: 10 },\r\n  { x: 10, y: 11 },\r\n  { x: 10, y: 12 }\r\n]\r\n\r\n\r\nexport const randomApplePos = (cols:number = BOARD_COLS, rows:number = BOARD_ROWS): Coord => {\r\n  const x = Math.floor(Math.random() * cols);\r\n  const y = Math.floor(Math.random() * rows);\r\n  // TODO: Don't collide with existing snake coords\r\n  // - Simple implementation would be load all snake coords\r\n  //   into two Sets of x and y then while() on the random\r\n  //   until a non-colliding coord is found.\r\n  return { x, y };\r\n}\r\n\r\nexport const isCoordEqual = (coord1: Coord, coord2: Coord) => {\r\n  return coord1.x === coord2.x && coord1.y === coord2.y;\r\n}\r\n\r\nexport const isSnakeCollision = (coord: Coord, snakeCoords: Coord[]) => {\r\n  return snakeCoords.some(snakeCoord => isCoordEqual(snakeCoord, coord))\r\n}\r\n\r\n\r\n// implemented as function otherwise randomApplePos() invokes on declaration\r\n// before unit tests can mock it out\r\nexport const initialState = (): SnakeGameShape => ({\r\n  applePos: randomApplePos(),\r\n  snakeCoords: INITIAL_SNAKE_COORDS,\r\n  direction: 'ArrowUp',\r\n  speedMs: null,\r\n  score: 0,\r\n  highScore: 0\r\n})","import React from \"react\"\r\nimport { BoardViewProps } from \"./types\"\r\nimport { isCoordEqual } from \"./utils\";\r\n\r\nconst BoardAscii = ({ cells, state }: BoardViewProps) => {\r\n  return (\r\n    <pre data-testid=\"asciitext\" style={{ backgroundColor: 'white', fontSize: '18px', lineHeight: '10px' }}>\r\n      {cells.map(\r\n        (row, i) => row.map(\r\n          (_: number, j: number) => {\r\n            const cellCoord = { x: j, y: i };\r\n            if (isCoordEqual(state.applePos, cellCoord)) {\r\n              return '*';\r\n            }\r\n            if (isCoordEqual(state.snakeCoords[0], cellCoord)) {\r\n              return 'o';\r\n            }\r\n            if (state.snakeCoords.some(coord => isCoordEqual(coord, cellCoord))) {\r\n              return '.';\r\n            }\r\n            return \" \";\r\n          }\r\n        ).join('') + '\\n'\r\n      )}\r\n    </pre>\r\n  )\r\n}\r\n\r\nexport default BoardAscii","import React, { useLayoutEffect, useRef } from \"react\"\r\nimport { BoardViewProps, Coord, SnakeGameShape } from \"./types\"\r\n\r\nconst CELL_WIDTH = 20;\r\n\r\nconst centerCoord = (coord) => {\r\n  return {\r\n    x: (coord.x * CELL_WIDTH) + Math.floor(CELL_WIDTH / 2),\r\n    y: (coord.y * CELL_WIDTH) + Math.floor(CELL_WIDTH / 2)\r\n  };\r\n}\r\n\r\nconst draw = (canvas: HTMLCanvasElement, rows: number, cols: number, cells: number[][], state: SnakeGameShape) => {\r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) {\r\n    return;\r\n  }\r\n  ctx.clearRect(0, 0, rows * CELL_WIDTH, cols * CELL_WIDTH);\r\n\r\n  ctx.lineWidth = CELL_WIDTH / 2;\r\n  ctx.lineCap = 'round';\r\n  ctx.miterLimit = 2;\r\n  ctx.strokeStyle = '#cccccc';\r\n\r\n  // Draw snake ...\r\n  // could easily improve this by drawing a \"head\" for the snake\r\n  state.snakeCoords.reduce((previous, coord) => {\r\n    if (previous != null) {\r\n      const lineCoord = centerCoord(coord);\r\n      ctx.lineTo(lineCoord.x, lineCoord.y);\r\n    } else {\r\n      ctx.beginPath();\r\n      const startPoint = centerCoord(coord);\r\n      ctx.moveTo(startPoint.x, startPoint.y);\r\n    }\r\n    if (coord === state.snakeCoords.slice(-1).shift()) {\r\n      ctx.stroke();\r\n    }\r\n    return coord;\r\n  }, null as Coord | null);\r\n\r\n  // Draw apple ...\r\n  // could easily improve this by drawing an Apple shape with bezier curve funcs etc\r\n  ctx.fillRect(state.applePos.x * CELL_WIDTH, state.applePos.y * CELL_WIDTH, CELL_WIDTH, CELL_WIDTH);\r\n\r\n  /* \r\n  \r\n  GitHub CoPilot generated this code in one go which is a 1:1 match to the HTML version!\r\n\r\n  cells.forEach((row, i) => {\r\n    row.forEach((_: number, j) => {\r\n      const cellCoord = { x: j, y: i };\r\n      if (isCoordEqual(state.applePos, cellCoord)) {\r\n        ctx.fillStyle = 'red';\r\n      } else if (isCoordEqual(state.snakeCoords[0], cellCoord)) {\r\n        ctx.fillStyle = 'grey';\r\n      } else if (state.snakeCoords.some(coord => isCoordEqual(coord, cellCoord))) {\r\n        ctx.fillStyle = 'darkgrey';\r\n      } else {\r\n        ctx.fillStyle = 'white';\r\n      }\r\n      ctx.fillRect(j * CELL_WIDTH, i * CELL_WIDTH, CELL_WIDTH, CELL_WIDTH);\r\n    });\r\n  });\r\n\r\n  */\r\n}\r\n\r\n// Specifically not memo'ing this. It will require re-render on the majority\r\n// of prop changes.\r\nconst BoardCanvas = ({ rows, cols, cells, state }: BoardViewProps) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  useLayoutEffect(() => {\r\n    if (canvasRef.current) {\r\n      draw(canvasRef.current, rows, cols, cells, state)\r\n    }\r\n  }, [canvasRef, state]);\r\n\r\n  return (\r\n    <div style={{ backgroundColor: 'white' }}>\r\n      <canvas\r\n        ref={canvasRef}\r\n        width={rows * CELL_WIDTH}\r\n        height={cols * CELL_WIDTH}\r\n      ></canvas>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default BoardCanvas","import React from 'react'\r\nimport styled from 'styled-components';\r\nimport { BoardViewProps, Coord, SnakeGameShape } from './types';\r\nimport { isCoordEqual } from './utils';\r\n\r\n\r\nconst cellColor = (state: SnakeGameShape, cellCoord: Coord) => {\r\n  if (isCoordEqual(state.applePos, cellCoord)) {\r\n    return 'red';\r\n  }\r\n  if (isCoordEqual(state.snakeCoords[0], cellCoord)) {\r\n    return 'grey';\r\n  }\r\n  if (state.snakeCoords.some(coord => isCoordEqual(coord, cellCoord))) {\r\n    return 'darkgrey';\r\n  }\r\n  return 'white';\r\n}\r\n\r\nconst Grid = styled.div<{ width: number, height: number }>`\r\n  width: ${props => props.width}px;\r\n  height: ${props => props.height}px;\r\n  display: inline-flex;\r\n  flex-wrap: wrap;\r\n`;\r\n\r\n/**\r\n * Most cells are blank, so we'll memo to prevent re-rendering expect where\r\n * the snake / apple changes colors. This has a big impact on browser performance\r\n * to prevent unnecessary re-rendering.\r\n */\r\nconst Cell = React.memo(styled.div<{ bgcolor: string, size: number }>`\r\n  width:${props => props.size}px;\r\n  height:${props => props.size}px;\r\n  background-color: ${props => props.bgcolor};\r\n  display: inline-block;\r\n`);\r\n\r\nconst CELL_WIDTH = 20;\r\n\r\nconst BoardHtml = ({ rows, cols, cells, state }: BoardViewProps) => {\r\n  return (\r\n    <Grid\r\n      width={rows * CELL_WIDTH} height={cols * CELL_WIDTH}\r\n    >\r\n      {cells.map((row, i) => row.map(\r\n        (_: number, j: number) =>\r\n          <Cell\r\n            size={CELL_WIDTH}\r\n            data-testid={`${i}, ${j}`}\r\n            key={`${i}, ${j}`}\r\n            bgcolor={cellColor(state, { x: j, y: i })}\r\n          />)\r\n      )}\r\n    </Grid>\r\n  )\r\n}\r\n\r\nexport default BoardHtml","import { Coord, SnakeDirection, SnakeGameAction, SnakeGameOperation, SnakeGameShape } from \"./types\";\r\nimport { BOARD_COLS, BOARD_ROWS, initialState, INITIAL_SNAKE_COORDS, INITIAL_SNAKE_SPEED, isCoordEqual, isSnakeCollision, randomApplePos } from \"./utils\";\r\n\r\ntype ReducerMap = { \r\n  [key in SnakeDirection | SnakeGameOperation]: (state: SnakeGameShape) => SnakeGameShape\r\n}\r\n\r\nexport const snakeGameReducer = (state: SnakeGameShape, action: SnakeGameAction) => {\r\n  const reducerMap: ReducerMap = {\r\n    [SnakeDirection.ArrowUp]: (state: SnakeGameShape) => {\r\n      if(state.direction === SnakeDirection.ArrowDown) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        direction: SnakeDirection.ArrowUp\r\n      }\r\n    },\r\n    [SnakeDirection.ArrowDown]: (state: SnakeGameShape) => {\r\n      if(state.direction === SnakeDirection.ArrowUp) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        direction: SnakeDirection.ArrowDown\r\n      }\r\n    },\r\n    [SnakeDirection.ArrowLeft]: (state: SnakeGameShape) => {\r\n      if(state.direction === SnakeDirection.ArrowRight) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        direction: SnakeDirection.ArrowLeft\r\n      }\r\n    },\r\n    [SnakeDirection.ArrowRight]: (state: SnakeGameShape) => {\r\n      if(state.direction === SnakeDirection.ArrowLeft) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        direction: SnakeDirection.ArrowRight\r\n      }\r\n    },\r\n    [SnakeGameOperation.Reset]: () => {\r\n      return {\r\n        ...initialState(),\r\n        highScore: state.highScore\r\n      }\r\n    },\r\n    [SnakeGameOperation.Start]: (state: SnakeGameShape) => {\r\n      return {\r\n        ...state,\r\n        speedMs: INITIAL_SNAKE_SPEED\r\n      }\r\n    },\r\n    [SnakeGameOperation.Advance]: (state: SnakeGameShape) => {\r\n      let newSnakeCoords = state.snakeCoords.slice();\r\n      const prevHead = state.snakeCoords[0];\r\n      let newHead: Coord | null = null;\r\n      let hitSomething = false;\r\n    \r\n      switch (state.direction) {\r\n        case 'ArrowUp':\r\n          newHead = { ...prevHead, y: prevHead.y - 1 };\r\n          if (prevHead.y === 0) { //at border\r\n            hitSomething = true; \r\n          } else {\r\n            newSnakeCoords = [\r\n              newHead,\r\n              ...state.snakeCoords.slice(0, state.snakeCoords.length - 1)\r\n            ]\r\n          }\r\n          break;\r\n        case 'ArrowDown':\r\n          newHead = { ...prevHead, y: prevHead.y + 1, };\r\n          if (prevHead.y === BOARD_ROWS - 1 ) { //at border\r\n            hitSomething = true;\r\n          } else {\r\n            newSnakeCoords = [\r\n              newHead,\r\n              ...state.snakeCoords.slice(0, state.snakeCoords.length - 1)\r\n            ]\r\n          }\r\n          break;\r\n        case 'ArrowLeft':\r\n          newHead = { ...prevHead, x: prevHead.x - 1, };\r\n          if (prevHead.x === 0) { //at border\r\n            hitSomething = true;\r\n          } else {\r\n            newSnakeCoords = [\r\n              newHead,\r\n              ...state.snakeCoords.slice(0, state.snakeCoords.length - 1)\r\n            ]\r\n          }\r\n          break;\r\n        case 'ArrowRight':\r\n          newHead = { ...prevHead, x: prevHead.x + 1, };\r\n          if (prevHead.x === BOARD_COLS - 1) {\r\n            hitSomething = true;\r\n          } else {\r\n            newSnakeCoords = [\r\n              newHead,\r\n              ...state.snakeCoords.slice(0, state.snakeCoords.length - 1)\r\n            ]\r\n          }\r\n          break;\r\n      }\r\n    \r\n      let newApplePos = state.applePos;\r\n      let newSpeed: number | null = state.speedMs ?? INITIAL_SNAKE_SPEED;\r\n      let score = state.score;\r\n      let newDirection = state.direction;\r\n      let newHighScore = state.highScore;\r\n    \r\n      // BUG: if snake reverses, will die\r\n      if(newHead !== null && !hitSomething) { // micro optimisation if we know there's already a collision\r\n        // this looks at all previous snake coords to detect collision, since newHead\r\n        // will be in new cell\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        hitSomething = isSnakeCollision(newHead!, state.snakeCoords)\r\n      }\r\n\r\n      // Hits apple\r\n      if (newHead && isCoordEqual(newHead, state.applePos)) {\r\n        newSpeed = newSpeed * 0.9;\r\n        // new applepos\r\n        newApplePos = randomApplePos();\r\n        // append old tail to extend tail\r\n        newSnakeCoords = [\r\n          ...newSnakeCoords,\r\n          state.snakeCoords[state.snakeCoords.length - 1]\r\n        ]\r\n        // increase score\r\n        score = score + 1;\r\n\r\n        // increase high score\r\n        if(score > state.highScore){\r\n          newHighScore = score;\r\n        }\r\n      }\r\n\r\n      if (hitSomething) {\r\n        newSpeed = null;\r\n        newApplePos = randomApplePos();\r\n        newSnakeCoords = INITIAL_SNAKE_COORDS;\r\n        score = 0;\r\n        newDirection = SnakeDirection.ArrowUp;\r\n      }\r\n    \r\n      return {\r\n        speedMs: newSpeed,\r\n        direction: newDirection,\r\n        applePos: newApplePos,\r\n        snakeCoords: newSnakeCoords,\r\n        score,\r\n        highScore: newHighScore\r\n      };\r\n    },\r\n  }\r\n\r\n  if(reducerMap[action.type]) {\r\n    return reducerMap[action.type](state);\r\n  }\r\n  \r\n  return state;\r\n};","import React, { useEffect, useReducer, useState } from 'react'\r\nimport styled from 'styled-components';\r\nimport BoardAscii from './BoardAscii';\r\nimport BoardCanvas from './BoardCanvas';\r\nimport BoardHtml from './BoardHtml';\r\nimport { snakeGameReducer } from './reducer';\r\nimport { SnakeDirection, SnakeGameOperation, ViewMode } from './types';\r\nimport { initialState, INITIAL_SNAKE_SPEED } from './utils';\r\n\r\nconst GameWrapper = styled.div`\r\n  outline:none;\r\n  display:inline-block;\r\n`\r\n\r\nconst Section = styled.section`\r\n  padding:10px;\r\n`;\r\n\r\nconst rows = 21;\r\nconst cols = 21;\r\n\r\nconst cells = Array.from(\r\n  Array(rows).keys()).map(() => Array.from(\r\n    Array(cols).keys()).map(() => (0))\r\n  );\r\n\r\n/**\r\n * Snake Game Container\r\n */\r\nconst SnakeGame = ({ viewMode }: { viewMode: ViewMode }) => {\r\n  const [viewType, setViewType] = useState<ViewMode>(viewMode)\r\n  const [state, dispatch] = useReducer(snakeGameReducer, initialState());\r\n\r\n  useEffect(() => {\r\n    const interval = setInterval(() => {\r\n      if (state.speedMs !== null) {\r\n        dispatch({ type: SnakeGameOperation.Advance });\r\n      }\r\n    }, state.speedMs ?? INITIAL_SNAKE_SPEED);\r\n    return () => {\r\n      clearInterval(interval);\r\n    }\r\n  }, [state.speedMs])\r\n\r\n  const handleGridKeyUp = (e: React.KeyboardEvent<HTMLDivElement>) => {\r\n    if (e.key === \"t\") {\r\n      const views = [ViewMode.Ascii, ViewMode.Canvas, ViewMode.Html];\r\n      setViewType(prev => views[(views.indexOf(prev) + 1) % views.length]);\r\n    }\r\n    if (state.speedMs === null) {\r\n      dispatch({ type: SnakeGameOperation.Start });\r\n    } else {\r\n      // Code smell: Marshalling all key events to the reducer here,\r\n      // should guard however they will just fall through\r\n      dispatch({ type: e.key as SnakeDirection });\r\n    }\r\n  }\r\n\r\n  const handleReset = () => {\r\n    dispatch({ type: SnakeGameOperation.Reset });\r\n  }\r\n\r\n  return (<div style={{ flexGrow: 2, padding: \"10px\" }}>\r\n    <Section role=\"note\">\r\n      Score: {state.score}. High Score: {state.highScore}\r\n    </Section>\r\n    <GameWrapper\r\n      role=\"application\"\r\n      tabIndex={0}\r\n      onKeyUp={handleGridKeyUp}\r\n      onClick={handleReset}\r\n    >\r\n      {viewType === ViewMode.Html && <BoardHtml\r\n        rows={rows}\r\n        cols={cols}\r\n        cells={cells}\r\n        state={state}\r\n      />}\r\n      {viewType === ViewMode.Ascii && <BoardAscii\r\n        rows={rows}\r\n        cols={cols}\r\n        cells={cells}\r\n        state={state}\r\n      />}\r\n      {viewType === ViewMode.Canvas && <BoardCanvas\r\n        rows={rows}\r\n        cols={cols}\r\n        cells={cells}\r\n        state={state}\r\n      />}\r\n\r\n    </GameWrapper>\r\n    <Section>\r\n      Press &apos;t&apos; to toggle view modes in game play (current mode: {viewType})\r\n    </Section>\r\n  </div >\r\n  )\r\n}\r\n\r\nexport default SnakeGame"],"names":["INITIAL_SNAKE_COORDS","x","y","randomApplePos","cols","rows","Math","floor","random","isCoordEqual","coord1","coord2","initialState","applePos","snakeCoords","direction","speedMs","score","highScore","cells","state","style","backgroundColor","fontSize","lineHeight","map","row","i","_","j","cellCoord","some","coord","join","CELL_WIDTH","centerCoord","canvasRef","useRef","useLayoutEffect","current","canvas","ctx","getContext","clearRect","lineWidth","lineCap","miterLimit","strokeStyle","reduce","previous","lineCoord","lineTo","beginPath","startPoint","moveTo","slice","shift","stroke","fillRect","draw","ref","width","height","cellColor","Grid","styled","props","Cell","React","size","bgcolor","snakeGameReducer","action","reducerMap","SnakeDirection","SnakeGameOperation","newSnakeCoords","prevHead","newHead","hitSomething","length","BOARD_ROWS","BOARD_COLS","newApplePos","newSpeed","newDirection","newHighScore","snakeCoord","type","GameWrapper","Section","Array","from","keys","viewMode","useState","viewType","setViewType","useReducer","dispatch","useEffect","interval","setInterval","clearInterval","flexGrow","padding","role","tabIndex","onKeyUp","e","key","views","ViewMode","prev","indexOf","onClick"],"sourceRoot":""}